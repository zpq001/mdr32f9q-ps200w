L 1 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\port.c"
N/*
N    FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>! NOTE: The modification to the GPL is included to allow you to distribute
N    >>! a combined work that includes FreeRTOS without being obliged to provide
N    >>! the source code for proprietary components outside of the FreeRTOS
N    >>! kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Implementation of functions defined in portable.h for the ARM CM3 port.
N *----------------------------------------------------------*/
N
N/* Scheduler includes. */
N#include "FreeRTOS.h"
L 1 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\FreeRTOS.h" 1
N/*
N    FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>! NOTE: The modification to the GPL is included to allow you to distribute
N    >>! a combined work that includes FreeRTOS without being obliged to provide
N    >>! the source code for proprietary components outside of the FreeRTOS
N    >>! kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "C:\Keil\ARM\RV31\Inc\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 102466 $
N * Checkin $Date: 2006-08-23 11:37:17 +0100 (Wed, 23 Aug 2006) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
Ntypedef signed int ptrdiff_t;
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* others (e.g. <stdio.h>) also define */
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32)
X    #if 0L
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
L 74 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\projdefs.h" 1
N/*
N    FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>! NOTE: The modification to the GPL is included to allow you to distribute
N    >>! a combined work that includes FreeRTOS without being obliged to provide
N    >>! the source code for proprietary components outside of the FreeRTOS
N    >>! kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/* Defines the prototype to which task functions must conform. */
Ntypedef void (*pdTASK_CODE)( void * );
N
N#define pdFALSE		( ( portBASE_TYPE ) 0 )
N#define pdTRUE		( ( portBASE_TYPE ) 1 )
N
N#define pdPASS									( pdTRUE )
N#define pdFAIL									( pdFALSE )
N#define errQUEUE_EMPTY							( ( portBASE_TYPE ) 0 )
N#define errQUEUE_FULL							( ( portBASE_TYPE ) 0 )
N
N/* Error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errNO_TASK_TO_RUN						( -2 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N#endif /* PROJDEFS_H */
N
N
N
L 77 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 ".\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>! NOTE: The modification to the GPL is included to allow you to distribute
N    >>! a combined work that includes FreeRTOS without being obliged to provide
N    >>! the source code for proprietary components outside of the FreeRTOS
N    >>! kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. 
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N
N#define configUSE_PREEMPTION		1
N#define configUSE_IDLE_HOOK			0
N#define configUSE_TICK_HOOK			1
N#define configCPU_CLOCK_HZ			( ( unsigned long ) 32000000 )	
N#define configTICK_RATE_HZ			( ( portTickType ) 500 )			// 2 ms
N#define configMAX_PRIORITIES		( ( unsigned portBASE_TYPE ) 5 )
N#define configMINIMAL_STACK_SIZE	( ( unsigned short ) 128 )
N#define configTOTAL_HEAP_SIZE		( ( size_t ) ( 17 * 1024 ) )
N#define configMAX_TASK_NAME_LEN		( 16 )
N#define configUSE_TRACE_FACILITY	0
N#define configUSE_16_BIT_TICKS		0
N#define configIDLE_SHOULD_YIELD		1
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES 		0
N#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
N
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N
N#define INCLUDE_vTaskPrioritySet		1
N#define INCLUDE_uxTaskPriorityGet		1
N#define INCLUDE_vTaskDelete				1
N#define INCLUDE_vTaskCleanUpResources	0
N#define INCLUDE_vTaskSuspend			1
N#define INCLUDE_vTaskDelayUntil			1
N#define INCLUDE_vTaskDelay				1
N
N/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255
N(lowest) to 0 (1?) (highest). */
N#define configKERNEL_INTERRUPT_PRIORITY 		255
N/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
NSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
N//#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	191 /* equivalent to 0xb0, or priority 11. */
N
N// Only bits [7:5] are implemented in MDR32F9Qx, so set highest priority 1
N// All other IRQs must be set to priorities >= 1 (and <= 7)
N#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	0x20	
N
N/* This is the value being used as per the ST library which permits 16
Npriority values, 0 to 15.  This must correspond to the
NconfigKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest
NNVIC value of 255. */
N#define configLIBRARY_KERNEL_INTERRUPT_PRIORITY	15
N
N
N
N#define vPortSVCHandler SVC_Handler
N#define xPortPendSVHandler PendSV_Handler
N#define xPortSysTickHandler SysTick_Handler
N
N#endif /* FREERTOS_CONFIG_H */
N
L 80 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* configUSE_PORT_OPTIMISED_TASK_SELECTION must be defined before portable.h
Nis included as it is used by the port layer. */
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\portable.h" 1
N/*
N    FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>! NOTE: The modification to the GPL is included to allow you to distribute
N    >>! a combined work that includes FreeRTOS without being obliged to provide
N    >>! the source code for proprietary components outside of the FreeRTOS
N    >>! kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Include the macro file relevant to the port being used. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "..\..\Source\portable\MPLAB\PIC24_dsPIC\portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "..\..\Source\portable\MPLAB\PIC24_dsPIC\portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "..\..\Source\portable\MPLAB\PIC18F\portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "..\..\Source\portable\MPLAB\PIC32MX\portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N/* Catch all to ensure portmacro.h is included in the build.  Newer demos
Nhave the path as part of the project options, rather than as relative from
Nthe project location.  If portENTER_CRITICAL() has not been defined then
Nportmacro.h has not yet been included - as every portmacro.h provides a
NportENTER_CRITICAL() definition.  Check the demo application for your demo
Nto find the path to the correct portmacro.h file. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\portmacro.h" 1
N/*
N    FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>! NOTE: The modification to the GPL is included to allow you to distribute
N    >>! a combined work that includes FreeRTOS without being obliged to provide
N    >>! the source code for proprietary components outside of the FreeRTOS
N    >>! kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	unsigned portLONG
N#define portBASE_TYPE	long
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef unsigned portSHORT portTickType;
S	#define portMAX_DELAY ( portTickType ) 0xffff
N#else
N	typedef unsigned portLONG portTickType;
X	typedef unsigned long portTickType;
N	#define portMAX_DELAY ( portTickType ) 0xffffffff
N#endif
N/*-----------------------------------------------------------*/
N
N/* Architecture specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_RATE_MS			( ( portTickType ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N/*-----------------------------------------------------------*/
N
N/* Scheduler utilities. */
Nextern void vPortYield( void );
N#define portNVIC_INT_CTRL_REG		( * ( ( volatile unsigned long * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
N#define portYIELD()					vPortYield()
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
N#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
N/*-----------------------------------------------------------*/
N
N/* Critical section management. */
Nextern unsigned long ulPortSetInterruptMask( void );
Nextern void vPortClearInterruptMask( unsigned long ulNewMask );
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
N
N#define portDISABLE_INTERRUPTS()				ulPortSetInterruptMask()
N#define portENABLE_INTERRUPTS()					vPortClearInterruptMask( 0 )
N#define portENTER_CRITICAL()					vPortEnterCritical()
N#define portEXIT_CRITICAL()						vPortExitCritical()
N#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortSetInterruptMask()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortClearInterruptMask(x)
N/*-----------------------------------------------------------*/
N
N/* Tickless idle/low power functionality. */
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	extern void vPortSuppressTicksAndSleep( portTickType xExpectedIdleTime );
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
N#endif
N/*-----------------------------------------------------------*/
N
N/* Port specific optimisations. */
N#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
X#if 0 == 1
S
S	/* Check the configuration. */
S	#if( configMAX_PRIORITIES > 32 )
S		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
S	#endif
S
S	/* Store/clear the ready priorities in a bit map. */
S	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
S	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
S
S	/*-----------------------------------------------------------*/
S
S	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31 - __clz( ( uxReadyPriorities ) ) )
S
N#endif /* taskRECORD_READY_PRIORITY */
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site.  These are
Nnot necessary for to use this port.  They are defined so the common demo files
N(which build with all the ports) will build. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
N/*-----------------------------------------------------------*/
N
N#ifdef configASSERT
S	void vPortValidateInterruptPriority( void );
S	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
N#endif
N
N/* portNOP() is not required by this port. */
N#define portNOP()
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 320 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\mpu_wrappers.h" 1
N/*
N    FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>! NOTE: The modification to the GPL is included to allow you to distribute
N    >>! a combined work that includes FreeRTOS without being obliged to provide
N    >>! the source code for proprietary components outside of the FreeRTOS
N    >>! kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		#define xTaskGenericCreate				MPU_xTaskGenericCreate
S		#define vTaskAllocateMPURegions			MPU_vTaskAllocateMPURegions
S		#define vTaskDelete						MPU_vTaskDelete
S		#define vTaskDelayUntil					MPU_vTaskDelayUntil
S		#define vTaskDelay						MPU_vTaskDelay
S		#define uxTaskPriorityGet				MPU_uxTaskPriorityGet
S		#define vTaskPrioritySet				MPU_vTaskPrioritySet
S		#define eTaskGetState					MPU_eTaskGetState
S		#define vTaskSuspend					MPU_vTaskSuspend
S		#define xTaskIsTaskSuspended			MPU_xTaskIsTaskSuspended
S		#define vTaskResume						MPU_vTaskResume
S		#define vTaskSuspendAll					MPU_vTaskSuspendAll
S		#define xTaskResumeAll					MPU_xTaskResumeAll
S		#define xTaskGetTickCount				MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks			MPU_uxTaskGetNumberOfTasks
S		#define vTaskList						MPU_vTaskList
S		#define vTaskGetRunTimeStats			MPU_vTaskGetRunTimeStats
S		#define vTaskSetApplicationTaskTag		MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag		MPU_xTaskGetApplicationTaskTag
S		#define xTaskCallApplicationTaskHook	MPU_xTaskCallApplicationTaskHook
S		#define uxTaskGetStackHighWaterMark		MPU_uxTaskGetStackHighWaterMark
S		#define xTaskGetCurrentTaskHandle		MPU_xTaskGetCurrentTaskHandle
S		#define xTaskGetSchedulerState			MPU_xTaskGetSchedulerState
S		#define xTaskGetIdleTaskHandle			MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState			MPU_uxTaskGetSystemState
S
S		#define xQueueGenericCreate				MPU_xQueueGenericCreate
S		#define xQueueCreateMutex				MPU_xQueueCreateMutex
S		#define xQueueGiveMutexRecursive		MPU_xQueueGiveMutexRecursive
S		#define xQueueTakeMutexRecursive		MPU_xQueueTakeMutexRecursive
S		#define xQueueCreateCountingSemaphore	MPU_xQueueCreateCountingSemaphore
S		#define xQueueGenericSend				MPU_xQueueGenericSend
S		#define xQueueAltGenericSend			MPU_xQueueAltGenericSend
S		#define xQueueAltGenericReceive			MPU_xQueueAltGenericReceive
S		#define xQueueGenericReceive			MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting			MPU_uxQueueMessagesWaiting
S		#define vQueueDelete					MPU_vQueueDelete
S		#define xQueueGenericReset				MPU_xQueueGenericReset
S		#define xQueueCreateSet					MPU_xQueueCreateSet
S		#define xQueueSelectFromSet				MPU_xQueueSelectFromSet
S		#define xQueueAddToSet					MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet				MPU_xQueueRemoveFromSet
S		#define xQueuePeekFromISR				MPU_xQueuePeekFromISR
S
S		#define pvPortMalloc					MPU_pvPortMalloc
S		#define vPortFree						MPU_vPortFree
S		#define xPortGetFreeHeapSize			MPU_xPortGetFreeHeapSize
S		#define vPortInitialiseBlocks			MPU_vPortInitialiseBlocks
S
S		#if configQUEUE_REGISTRY_SIZE > 0
S			#define vQueueAddToRegistry				MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue			MPU_vQueueUnregisterQueue
S		#endif
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 351 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters, portBASE_TYPE xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	unsigned long *pxPortInitialiseStack( unsigned long *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters ) ;
N#endif
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NportBASE_TYPE xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
Xlong xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, portSTACK_TYPE *pxBottomOfStack, unsigned short usStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 89 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N
N/* Defines the prototype to which the application task hook function must
Nconform. */
Ntypedef portBASE_TYPE (*pdTASK_HOOK_CODE)( void * );
Xtypedef long (*pdTASK_HOOK_CODE)( void * );
N
N
N
N
N
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#error  Missing definition:  configUSE_CO_ROUTINES should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#error Missing definition:  INCLUDE_vTaskPrioritySet should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#error Missing definition:  INCLUDE_uxTaskPriorityGet should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#error Missing definition:  INCLUDE_vTaskDelete		 should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#error Missing definition:  INCLUDE_vTaskSuspend	 should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#error Missing definition:  INCLUDE_vTaskDelayUntil should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#error Missing definition:  INCLUDE_vTaskDelay should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTimerGetTimerDaemonTaskHandle
N	#define INCLUDE_xTimerGetTimerDaemonTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_pcTaskGetTaskName
N	#define INCLUDE_pcTaskGetTaskName 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
N	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
N	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
N	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
N	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
N	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
N	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 16 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef configASSERT
N	#define configASSERT( x )
N	#define configASSERT_DEFINED 0
N#else
S	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
S	#endif /* configTIMER_TASK_PRIORITY */
S
S	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
S	#endif /* configTIMER_QUEUE_LENGTH */
S
S	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
S	#endif /* configTIMER_TASK_STACK_DEPTH */
S
N#endif /* configUSE_TIMERS */
N
N#ifndef INCLUDE_xTaskGetSchedulerState
N	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
N	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
N	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 0U < 1 )
N	#define vQueueAddToRegistry( xQueue, pcName )
N	#define vQueueUnregisterQueue( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE unsigned long
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
N	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL()
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
N	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
N	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( unsigned portBASE_TYPE ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef pvPortMallocAligned
N	#define pvPortMallocAligned( x, puxStackBuffer ) ( ( ( puxStackBuffer ) == NULL ) ? ( pvPortMalloc( ( x ) ) ) : ( puxStackBuffer ) )
N#endif
N
N#ifndef vPortFreeAligned
N	#define vPortFreeAligned( pvBlockToFree ) vPortFree( pvBlockToFree )
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
S	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
N	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
N	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N/* For backward compatability. */
N#define eTaskStateGet eTaskGetState
N
N#endif /* INC_FREERTOS_H */
N
L 72 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\port.c" 2
N#include "task.h"
L 1 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\task.h" 1
N/*
N    FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>! NOTE: The modification to the GPL is included to allow you to distribute
N    >>! a combined work that includes FreeRTOS without being obliged to provide
N    >>! the source code for proprietary components outside of the FreeRTOS
N    >>! kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\list.h" 1
N/*
N    FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that has become a de facto standard.             *
N     *                                                                       *
N     *    Help yourself get started quickly and support the FreeRTOS         *
N     *    project by purchasing a FreeRTOS tutorial book, reference          *
N     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
N     *                                                                       *
N     *    Thank you!                                                         *
N     *                                                                       *
N    ***************************************************************************
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    >>! NOTE: The modification to the GPL is included to allow you to distribute
N    >>! a combined work that includes FreeRTOS without being obliged to provide
N    >>! the source code for proprietary components outside of the FreeRTOS
N    >>! kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
N    link: http://www.freertos.org/a00114.html
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * xLists can only store pointers to xListItems.  Each xListItem contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).  
N * If configLIST_VOLATILE is not defined then the preprocessor directives below 
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	configLIST_VOLATILE portTickType xItemValue;	/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 portTickType xItemValue;	 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;	/*< Pointer to the next xListItem in the list. */
X	struct xLIST_ITEM *  pxNext;	 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;/*< Pointer to the previous xListItem in the list. */
X	struct xLIST_ITEM *  pxPrevious; 
N	void * pvOwner;									/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;			/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;			 
N};
Ntypedef struct xLIST_ITEM xListItem;				/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	configLIST_VOLATILE portTickType xItemValue;
X	 portTickType xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM xMiniListItem;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	configLIST_VOLATILE unsigned portBASE_TYPE uxNumberOfItems;
X	 unsigned long uxNumberOfItems;
N	xListItem * configLIST_VOLATILE pxIndex;		/*< Used to walk through the list.  Points to the last item returned by a call to pvListGetOwnerOfNextEntry (). */
X	xListItem *  pxIndex;		 
N	xMiniListItem xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N} xList;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )		( pxListItem )->pvOwner
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )		( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example a the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )				( ( pxListItem )->xItemValue )
N
N/*
N * Access macro the retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )			( (&( ( pxList )->xListEnd ))->pxNext->xItemValue )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )				( ( portBASE_TYPE ) ( ( pxList )->uxNumberOfItems == ( unsigned portBASE_TYPE ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )		( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entries pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NxList * const pxConstList = ( pxList );														\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							xList * const pxConstList = ( pxList );															 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE is the list item is in the list, otherwise pdFALSE.
N * pointer against
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( portBASE_TYPE ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the xList object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( xList * const pxList );
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( xListItem * const pxItem );
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item to that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( xList * const pxList, xListItem * const pxNewListItem );
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pvIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pvIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pvIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pvIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( xList * const pxList, xListItem * const pxNewListItem );
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
Nunsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove );
Xunsigned long uxListRemove( xListItem * const pxItemToRemove );
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 75 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V7.5.3"
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an xTaskHandle variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup xTaskHandle xTaskHandle
N * \ingroup Tasks
N */
Ntypedef void * xTaskHandle;
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N} eTaskState;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	portBASE_TYPE xOverflowCount;
X	long xOverflowCount;
N	portTickType  xTimeOnEntering;
N} xTimeOutType;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	unsigned long ulLengthInBytes;
N	unsigned long ulParameters;
N} xMemoryRegion;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMTERS
N{
N	pdTASK_CODE pvTaskCode;
N	const signed char * const pcName;
N	unsigned short usStackDepth;
N	void *pvParameters;
N	unsigned portBASE_TYPE uxPriority;
X	unsigned long uxPriority;
N	portSTACK_TYPE *puxStackBuffer;
X	unsigned long *puxStackBuffer;
N	xMemoryRegion xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	xMemoryRegion xRegions[ 1 ];
N} xTaskParameters;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	xTaskHandle xHandle;						/* The handle of the task to which the rest of the information in the structure relates. */
N	const signed char *pcTaskName;				/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */
N	unsigned portBASE_TYPE xTaskNumber;			/* A number unique to the task. */
X	unsigned long xTaskNumber;			 
N	eTaskState eCurrentState;					/* The state in which the task existed when the structure was populated. */
N	unsigned portBASE_TYPE uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
X	unsigned long uxCurrentPriority;	 
N	unsigned portBASE_TYPE uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
X	unsigned long uxBasePriority;		 
N	unsigned long ulRunTimeCounter;				/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	unsigned short usStackHighWaterMark;		/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} xTaskStatusType;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N
N/*
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( unsigned portBASE_TYPE ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState(). */
N#define taskSCHEDULER_NOT_STARTED	( ( portBASE_TYPE ) 0 )
N#define taskSCHEDULER_RUNNING		( ( portBASE_TYPE ) 1 )
N#define taskSCHEDULER_SUSPENDED		( ( portBASE_TYPE ) 2 )
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N portBASE_TYPE xTaskCreate(
N							  pdTASK_CODE pvTaskCode,
N							  const char * const pcName,
N							  unsigned short usStackDepth,
N							  void *pvParameters,
N							  unsigned portBASE_TYPE uxPriority,
N							  xTaskHandle *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by tskMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file errors. h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static unsigned char ucParameterToPass;
N xTaskHandle xHandle;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#define xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask ) xTaskGenericCreate( ( pvTaskCode ), ( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask ), ( NULL ), ( NULL ) )
N
N/**
N * task. h
N *<pre>
N portBASE_TYPE xTaskCreateRestricted( xTaskParameters *pxTaskDefinition, xTaskHandle *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file errors. h
N *
N * Example usage:
N   <pre>
N// Create an xTaskParameters structure that defines the task to be created.
Nstatic const xTaskParameters xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NxTaskHandle xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#define xTaskCreateRestricted( x, pxCreatedTask ) xTaskGenericCreate( ((x)->pvTaskCode), ((x)->pcName), ((x)->usStackDepth), ((x)->pvParameters), ((x)->uxPriority), (pxCreatedTask), ((x)->puxStackBuffer), ((x)->xRegions) )
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( xTaskHandle xTask, const xMemoryRegion * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an xMemoryRegion structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of xMemoryRegion structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const xMemoryRegion xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( xTaskHandle xTask, const xMemoryRegion * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( xTaskHandle xTask, const xMemoryRegion * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( xTaskHandle xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernels management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( xTaskHandle xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( xTaskHandle xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( portTickType xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_RATE_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a cyclical task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const portTickType xDelay = 500 / portTICK_RATE_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( portTickType xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( portTickType xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( portTickType *pxPreviousWakeTime, portTickType xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by cyclical
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_RATE_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N portTickType xLastWakeTime;
N const portTickType xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask );</pre>
N *
N * INCLUDE_xTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
Nunsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
Xunsigned long uxTaskPriorityGet( xTaskHandle xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( xTaskHandle xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( xTaskHandle xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( xTaskHandle xTask, unsigned long uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( xTaskHandle xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( xTaskHandle xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( xTaskHandle xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( xTaskHandle xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one of more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with it priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( xTaskHandle xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( xTaskHandle xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( xTaskHandle xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one of more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NportBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume ) PRIVILEGED_FUNCTION;
Xlong xTaskResumeFromISR( xTaskHandle xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.  This function
N * does not return until an executing task calls vTaskEndScheduler ().
N *
N * At least one task should be created via a call to xTaskCreate ()
N * before calling vTaskStartScheduler ().  The idle task is created
N * automatically when the first application task is created.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends all real time kernel activity while keeping interrupts (including the
N * kernel tick) enabled.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>char xTaskResumeAll( void );</pre>
N *
N * Resumes real time kernel activity following a call to vTaskSuspendAll ().
N * After a call to vTaskSuspendAll () the kernel will take control of which
N * task is executing at any time.
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
Nsigned portBASE_TYPE xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
Xsigned long xTaskResumeAll( void ) ;
N
N/**
N * task. h
N * <pre>signed portBASE_TYPE xTaskIsTaskSuspended( const xTaskHandle xTask );</pre>
N *
N * Utility task that simply returns pdTRUE if the task referenced by xTask is
N * currently in the Suspended state, or pdFALSE if the task referenced by xTask
N * is in any other state.
N *
N */
Nsigned portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
Xsigned long xTaskIsTaskSuspended( xTaskHandle xTask ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>portTickType xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NportTickType xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XportTickType xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>portTickType xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that portTickType is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NportTickType xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XportTickType xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>unsigned short uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
Nunsigned portBASE_TYPE uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
Xunsigned long uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQueury.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be
N * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.
N *
N * \defgroup pcTaskGetTaskName pcTaskGetTaskName
N * \ingroup TaskUtils
N */
Nsigned char *pcTaskGetTaskName( xTaskHandle xTaskToQuery );
N
N/**
N * task.h
N * <PRE>unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in bytes)
N * since the task referenced by xTask was created.
N */
Nunsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
Xunsigned long uxTaskGetStackHighWaterMark( xTaskHandle xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include tasks.h before
NFreeRTOS.h.  When this is done pdTASK_HOOK_CODE will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( xTaskHandle xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N/**
N * task.h
N * <pre>portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.
N */
NportBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
Xlong xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NxTaskHandle xTaskGetIdleTaskHandle( void );
N
N/**
N * configUSE_TRACE_FACILITY must bet defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an xTaskStatusType structure for each task in
N * the system.  xTaskStatusType structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the xTaskStatusType structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of xTaskStatusType structures.
N * The array must contain at least one xTaskStatusType structure for each task 
N * that is under the control of the RTOS.  The number of tasks under the control 
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of xTaskStatusType structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of xTaskStatusType structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
N	{
N	xTaskStatusType *pxTaskStatusArray;
N	volatile unsigned portBASE_TYPE uxArraySize, x;
N	unsigned long ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxCurrentNumberOfTasks();
N
N		// Allocate a xTaskStatusType structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( xTaskStatusType ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
Nunsigned portBASE_TYPE uxTaskGetSystemState( xTaskStatusType *pxTaskStatusArray, unsigned portBASE_TYPE uxArraySize, unsigned long *pulTotalRunTime );
Xunsigned long uxTaskGetSystemState( xTaskStatusType *pxTaskStatusArray, unsigned long uxArraySize, unsigned long *pulTotalRunTime );
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ascii form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( signed char *pcWriteBuffer ) PRIVILEGED_FUNCTION;
Xvoid vTaskList( signed char *pcWriteBuffer ) ;
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ascii form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( signed char *pcWriteBuffer ) PRIVILEGED_FUNCTION;
Xvoid vTaskGetRunTimeStats( signed char *pcWriteBuffer ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NportBASE_TYPE xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
Xlong xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_RATE_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
Nvoid vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList () will be called if either an event occurs to
N * unblock a task, or the block timeout period expires.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
Nsigned portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList ) PRIVILEGED_FUNCTION;
Xsigned long xTaskRemoveFromEventList( const xList * const pxEventList ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NxTaskHandle xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XxTaskHandle xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( xTimeOutType * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( xTimeOutType * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NportBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait ) PRIVILEGED_FUNCTION;
Xlong xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NportBASE_TYPE xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
Xlong xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( xTaskHandle const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( xTaskHandle const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
Nvoid vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder ) ;
N
N/*
N * Generic version of the task creation function which is in turn called by the
N * xTaskCreate() and xTaskCreateRestricted() macros.
N */
Nsigned portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions ) PRIVILEGED_FUNCTION;
Xsigned long xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned long uxPriority, xTaskHandle *pxCreatedTask, unsigned long *puxStackBuffer, const xMemoryRegion * const xRegions ) ;
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
Nunsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask );
Xunsigned long uxTaskGetTaskNumber( xTaskHandle xTask );
N
N/*
N * Set the uxTCBNumber of the task referenced by the xTask parameter to
N * ucHandle.
N */
Nvoid vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle );
Xvoid vTaskSetTaskNumber( xTaskHandle xTask, unsigned long uxHandle );
N
N/*
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by the by
N * a time equal to the idle period.
N */
Nvoid vTaskStepTick( portTickType xTicksToJump );
N
N/*
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void );
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 73 "..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\port.c" 2
N
N#ifndef configKERNEL_INTERRUPT_PRIORITY
S	#define configKERNEL_INTERRUPT_PRIORITY 255
N#endif
N
N#if configMAX_SYSCALL_INTERRUPT_PRIORITY == 0
X#if 0x20 == 0
S	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
N#endif
N
N#ifndef configSYSTICK_CLOCK_HZ
N	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
N#endif
N
N/* The __weak attribute does not work as you might expect with the Keil tools
Nso the configOVERRIDE_DEFAULT_TICK_CONFIGURATION constant must be set to 1 if
Nthe application writer wants to provide their own implementation of
NvPortSetupTimerInterrupt().  Ensure configOVERRIDE_DEFAULT_TICK_CONFIGURATION
Nis defined. */
N#ifndef configOVERRIDE_DEFAULT_TICK_CONFIGURATION
N	#define configOVERRIDE_DEFAULT_TICK_CONFIGURATION 0
N#endif
N
N/* Constants required to manipulate the core.  Registers first... */
N#define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile unsigned long * ) 0xe000e010 ) )
N#define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile unsigned long * ) 0xe000e014 ) )
N#define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile unsigned long * ) 0xe000e018 ) )
N#define portNVIC_SYSPRI2_REG				( * ( ( volatile unsigned long * ) 0xe000ed20 ) )
N/* ...then bits in the registers. */
N#define portNVIC_SYSTICK_CLK_BIT			( 1UL << 2UL )
N#define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
N#define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
N#define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
N#define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
N#define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
N
N#define portNVIC_PENDSV_PRI					( ( ( unsigned long ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
N#define portNVIC_SYSTICK_PRI				( ( ( unsigned long ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
N
N/* Constants required to check the validity of an interrupt priority. */
N#define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
N#define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
N#define portAIRCR_REG						( * ( ( volatile unsigned long * ) 0xE000ED0C ) )
N#define portMAX_8_BIT_VALUE					( ( unsigned char ) 0xff )
N#define portTOP_BIT_OF_BYTE					( ( unsigned char ) 0x80 )
N#define portMAX_PRIGROUP_BITS				( ( unsigned char ) 7 )
N#define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
N#define portPRIGROUP_SHIFT					( 8UL )
N
N/* Constants required to set up the initial stack. */
N#define portINITIAL_XPSR			( 0x01000000 )
N
N/* Constants used with memory barrier intrinsics. */
N#define portSY_FULL_READ_WRITE		( 15 )
N
N/* The systick is a 24-bit counter. */
N#define portMAX_24_BIT_NUMBER				( 0xffffffUL )
N
N/* A fiddle factor to estimate the number of SysTick counts that would have
Noccurred while the SysTick counter is stopped during tickless idle
Ncalculations. */
N#define portMISSED_COUNTS_FACTOR			( 45UL )
N
N/* Each task maintains its own interrupt status in the critical nesting
Nvariable. */
Nstatic unsigned portBASE_TYPE uxCriticalNesting = 0xaaaaaaaa;
Xstatic unsigned long uxCriticalNesting = 0xaaaaaaaa;
N
N/*
N * Setup the timer to generate the tick interrupts.  The implementation in this
N * file is weak to allow application writers to change the timer used to
N * generate the tick interrupt.
N */
Nvoid vPortSetupTimerInterrupt( void );
N
N/*
N * Exception handlers.
N */
Nvoid xPortPendSVHandler( void );
Xvoid PendSV_Handler( void );
Nvoid xPortSysTickHandler( void );
Xvoid SysTick_Handler( void );
Nvoid vPortSVCHandler( void );
Xvoid SVC_Handler( void );
N
N/*
N * Start first task is a separate function so it can be tested in isolation.
N */
Nstatic void prvStartFirstTask( void );
N
N/*
N * Used to catch tasks that attempt to return from their implementing function.
N */
Nstatic void prvTaskExitError( void );
N
N/*-----------------------------------------------------------*/
N
N/*
N * The number of SysTick increments that make up one tick period.
N */
N#if configUSE_TICKLESS_IDLE == 1
X#if 0 == 1
S	static unsigned long ulTimerCountsForOneTick = 0;
N#endif /* configUSE_TICKLESS_IDLE */
N
N/*
N * The maximum number of tick periods that can be suppressed is limited by the
N * 24 bit resolution of the SysTick timer.
N */
N#if configUSE_TICKLESS_IDLE == 1
X#if 0 == 1
S	static unsigned long xMaximumPossibleSuppressedTicks = 0;
N#endif /* configUSE_TICKLESS_IDLE */
N
N/*
N * Compensate for the CPU cycles that pass while the SysTick is stopped (low
N * power functionality only.
N */
N#if configUSE_TICKLESS_IDLE == 1
X#if 0 == 1
S	static unsigned long ulStoppedTimerCompensation = 0;
N#endif /* configUSE_TICKLESS_IDLE */
N
N/*
N * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure 
N * FreeRTOS API functions are not called from interrupts that have been assigned
N * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
N */
N#if ( configASSERT_DEFINED == 1 )
X#if ( 0 == 1 )
S	 static unsigned char ucMaxSysCallPriority = 0;
S	 static unsigned long ulMaxPRIGROUPValue = 0;
S	 static const volatile unsigned char * const pcInterruptPriorityRegisters = ( unsigned char * ) portNVIC_IP_REGISTERS_OFFSET_16;
N#endif /* configASSERT_DEFINED */
N
N/*-----------------------------------------------------------*/
N
N/*
N * See header file for description.
N */
NportSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
Xunsigned long *pxPortInitialiseStack( unsigned long *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
N{
N	/* Simulate the stack frame as it would be created by a context switch
N	interrupt. */
N	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
N	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
X	*pxTopOfStack = ( 0x01000000 );	 
N	pxTopOfStack--;
N	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
X	*pxTopOfStack = ( unsigned long ) pxCode;	 
N	pxTopOfStack--;
N	*pxTopOfStack = ( portSTACK_TYPE ) prvTaskExitError;	/* LR */
X	*pxTopOfStack = ( unsigned long ) prvTaskExitError;	 
N
N	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
N	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
X	*pxTopOfStack = ( unsigned long ) pvParameters;	 
N	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
N
N	return pxTopOfStack;
N}
N/*-----------------------------------------------------------*/
N
Nstatic void prvTaskExitError( void )
N{
N	/* A function that implements a task must not exit or attempt to return to
N	its caller as there is nothing to return to.  If a task wants to exit it 
N	should instead call vTaskDelete( NULL ).
N	
N	Artificially force an assert() to be triggered if configASSERT() is 
N	defined, then stop here so application writers can catch the error. */
N	configASSERT( uxCriticalNesting == ~0UL );
X	;
N	portDISABLE_INTERRUPTS();	
X	ulPortSetInterruptMask();	
N	for( ;; );
N}
N/*-----------------------------------------------------------*/
N
N__asm void vPortSVCHandler( void )
X__asm void SVC_Handler( void )
N{
N	PRESERVE8
N
N	ldr	r3, =pxCurrentTCB	/* Restore the context. */
N	ldr r1, [r3]			/* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
N	ldr r0, [r1]			/* The first item in pxCurrentTCB is the task top of stack. */
N	ldmia r0!, {r4-r11}		/* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */
N	msr psp, r0				/* Restore the task stack pointer. */
N	mov r0, #0
N	msr	basepri, r0
N	orr r14, #0xd
N	bx r14
N}
N/*-----------------------------------------------------------*/
N
N__asm void prvStartFirstTask( void )
N{
N	PRESERVE8
N
N	/* Use the NVIC offset register to locate the stack. */
N	ldr r0, =0xE000ED08
N	ldr r0, [r0]
N	ldr r0, [r0]
N	/* Set the msp back to the start of the stack. */
N	msr msp, r0
N	/* Globally enable interrupts. */
N	cpsie i
N	/* Call SVC to start the first task. */
N	svc 0
N	nop
N}
N/*-----------------------------------------------------------*/
N
N/*
N * See header file for description.
N */
NportBASE_TYPE xPortStartScheduler( void )
Xlong xPortStartScheduler( void )
N{
N	#if( configASSERT_DEFINED == 1 )
X	#if( 0 == 1 )
S	{
S		volatile unsigned long ulOriginalPriority;
S		volatile char * const pcFirstUserPriorityRegister = ( char * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
S		volatile unsigned char ucMaxPriorityValue;
S
S		/* Determine the maximum priority from which ISR safe FreeRTOS API
S		functions can be called.  ISR safe functions are those that end in
S		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
S		ensure interrupt entry is as fast and simple as possible.
S
S		Save the interrupt priority value that is about to be clobbered. */
S		ulOriginalPriority = *pcFirstUserPriorityRegister;
S
S		/* Determine the number of priority bits available.  First write to all
S		possible bits. */
S		*pcFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
S
S		/* Read the value back to see how many bits stuck. */
S		ucMaxPriorityValue = *pcFirstUserPriorityRegister;
S
S		/* Use the same mask on the maximum system call priority. */
S		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
S
S		/* Calculate the maximum acceptable priority group value for the number
S		of bits read back. */
S		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
S		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
S		{
S			ulMaxPRIGROUPValue--;
S			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
S		}
S
S		/* Shift the priority group value back to its position within the AIRCR
S		register. */
S		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
S		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
S
S		/* Restore the clobbered interrupt priority register to its original
S		value. */
S		*pcFirstUserPriorityRegister = ulOriginalPriority;
S	}
N	#endif /* conifgASSERT_DEFINED */
N
N	/* Make PendSV and SysTick the lowest priority interrupts. */
N	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
X	( * ( ( volatile unsigned long * ) 0xe000ed20 ) ) |= ( ( ( unsigned long ) 255 ) << 16UL );
N	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
X	( * ( ( volatile unsigned long * ) 0xe000ed20 ) ) |= ( ( ( unsigned long ) 255 ) << 24UL );
N
N	/* Start the timer that generates the tick ISR.  Interrupts are disabled
N	here already. */
N	vPortSetupTimerInterrupt();
N
N	/* Initialise the critical nesting count ready for the first task. */
N	uxCriticalNesting = 0;
N
N	/* Start the first task. */
N	prvStartFirstTask();
N
N	/* Should not get here! */
N	return 0;
N}
N/*-----------------------------------------------------------*/
N
Nvoid vPortEndScheduler( void )
N{
N	/* It is unlikely that the CM3 port will require this function as there
N	is nothing to return to.  */
N}
N/*-----------------------------------------------------------*/
N
Nvoid vPortYield( void )
N{
N	/* Set a PendSV to request a context switch. */
N	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
X	( * ( ( volatile unsigned long * ) 0xe000ed04 ) ) = ( 1UL << 28UL );
N
N	/* Barriers are normally not required but do ensure the code is completely
N	within the specified behaviour for the architecture. */
N	__dsb( portSY_FULL_READ_WRITE );
X	__dsb( ( 15 ) );
N	__isb( portSY_FULL_READ_WRITE );
X	__isb( ( 15 ) );
N}
N/*-----------------------------------------------------------*/
N
Nvoid vPortEnterCritical( void )
N{
N	portDISABLE_INTERRUPTS();
X	ulPortSetInterruptMask();
N	uxCriticalNesting++;
N	__dsb( portSY_FULL_READ_WRITE );
X	__dsb( ( 15 ) );
N	__isb( portSY_FULL_READ_WRITE );
X	__isb( ( 15 ) );
N}
N/*-----------------------------------------------------------*/
N
Nvoid vPortExitCritical( void )
N{
N	uxCriticalNesting--;
N	if( uxCriticalNesting == 0 )
N	{
N		portENABLE_INTERRUPTS();
X		vPortClearInterruptMask( 0 );
N	}
N}
N/*-----------------------------------------------------------*/
N
N__asm void xPortPendSVHandler( void )
X__asm void PendSV_Handler( void )
N{
N	extern uxCriticalNesting;
N	extern pxCurrentTCB;
N	extern vTaskSwitchContext;
N
N	PRESERVE8
N
N	mrs r0, psp
N
N	ldr	r3, =pxCurrentTCB		/* Get the location of the current TCB. */
N	ldr	r2, [r3]
N
N	stmdb r0!, {r4-r11}			/* Save the remaining registers. */
N	str r0, [r2]				/* Save the new top of stack into the first member of the TCB. */
N
N	stmdb sp!, {r3, r14}
N	mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY
X	mov r0, #0x20
N	msr basepri, r0
N	bl vTaskSwitchContext
N	mov r0, #0
N	msr basepri, r0
N	ldmia sp!, {r3, r14}
N
N	ldr r1, [r3]
N	ldr r0, [r1]				/* The first item in pxCurrentTCB is the task top of stack. */
N	ldmia r0!, {r4-r11}			/* Pop the registers and the critical nesting count. */
N	msr psp, r0
N	bx r14
N	nop
N}
N/*-----------------------------------------------------------*/
N
Nvoid xPortSysTickHandler( void )
Xvoid SysTick_Handler( void )
N{
N	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
N	executes all interrupts must be unmasked.  There is therefore no need to
N	save and then restore the interrupt mask value as its value is already
N	known. */
N	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
X	( void ) ulPortSetInterruptMask();
N	{
N		/* Increment the RTOS tick. */
N		if( xTaskIncrementTick() != pdFALSE )
X		if( xTaskIncrementTick() != ( ( long ) 0 ) )
N		{
N			/* A context switch is required.  Context switching is performed in
N			the PendSV interrupt.  Pend the PendSV interrupt. */
N			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
X			( * ( ( volatile unsigned long * ) 0xe000ed04 ) ) = ( 1UL << 28UL );
N		}
N	}
N	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
X	vPortClearInterruptMask(0);
N}
N/*-----------------------------------------------------------*/
N
N#if configUSE_TICKLESS_IDLE == 1
X#if 0 == 1
S
S	__weak void vPortSuppressTicksAndSleep( portTickType xExpectedIdleTime )
S	{
S	unsigned long ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
S	portTickType xModifiableIdleTime;
S
S		/* Make sure the SysTick reload value does not overflow the counter. */
S		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
S		{
S			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
S		}
S
S		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
S		is accounted for as best it can be, but using the tickless mode will
S		inevitably result in some tiny drift of the time maintained by the
S		kernel with respect to calendar time. */
S		portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT;
S
S		/* Calculate the reload value required to wait xExpectedIdleTime
S		tick periods.  -1 is used because this code will execute part way
S		through one of the tick periods. */
S		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
S		if( ulReloadValue > ulStoppedTimerCompensation )
S		{
S			ulReloadValue -= ulStoppedTimerCompensation;
S		}
S
S		/* Enter a critical section but don't use the taskENTER_CRITICAL()
S		method as that will mask interrupts that should exit sleep mode. */
S		__disable_irq();
S
S		/* If a context switch is pending or a task is waiting for the scheduler
S		to be unsuspended then abandon the low power entry. */
S		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
S		{
S			/* Restart from whatever is left in the count register to complete
S			this tick period. */
S			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
S			
S			/* Restart SysTick. */
S			portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
S			
S			/* Reset the reload register to the value required for normal tick
S			periods. */
S			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
S
S			/* Re-enable interrupts - see comments above __disable_irq() call
S			above. */
S			__enable_irq();
S		}
S		else
S		{
S			/* Set the new reload value. */
S			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
S
S			/* Clear the SysTick count flag and set the count value back to
S			zero. */
S			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
S
S			/* Restart SysTick. */
S			portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
S
S			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
S			set its parameter to 0 to indicate that its implementation contains
S			its own wait for interrupt or wait for event instruction, and so wfi
S			should not be executed again.  However, the original expected idle
S			time variable must remain unmodified, so a copy is taken. */
S			xModifiableIdleTime = xExpectedIdleTime;
S			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
S			if( xModifiableIdleTime > 0 )
S			{
S				__dsb( portSY_FULL_READ_WRITE );
S				__wfi();
S				__isb( portSY_FULL_READ_WRITE );
S			}
S			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
S
S			/* Stop SysTick.  Again, the time the SysTick is stopped for is
S			accounted for as best it can be, but using the tickless mode will
S			inevitably result in some tiny drift of the time maintained by the
S			kernel with respect to calendar time. */
S			portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT;
S
S			/* Re-enable interrupts - see comments above __disable_irq() call
S			above. */
S			__enable_irq();
S
S			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
S			{
S				unsigned long ulCalculatedLoadValue;
S				
S				/* The tick interrupt has already executed, and the SysTick
S				count reloaded with ulReloadValue.  Reset the
S				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
S				period. */
S				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
S
S				/* Don't allow a tiny value, or values that have somehow 
S				underflowed because the post sleep hook did something 
S				that took too long. */
S				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
S				{
S					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
S				}
S				
S				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
S				
S				/* The tick interrupt handler will already have pended the tick
S				processing in the kernel.  As the pending tick will be
S				processed as soon as this function exits, the tick value
S				maintained by the tick is stepped forward by one less than the
S				time spent waiting. */
S				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
S			}
S			else
S			{
S				/* Something other than the tick interrupt ended the sleep.
S				Work out how long the sleep lasted rounded to complete tick
S				periods (not the ulReload value which accounted for part
S				ticks). */
S				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
S
S				/* How many complete tick periods passed while the processor
S				was waiting? */
S				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
S
S				/* The reload value is set to whatever fraction of a single tick
S				period remains. */
S				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1 ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
S			}
S
S			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
S			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
S			value.  The critical section is used to ensure the tick interrupt
S			can only execute once in the case that the reload register is near
S			zero. */
S			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
S			portENTER_CRITICAL();
S			{
S				portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
S				vTaskStepTick( ulCompleteTickPeriods );
S				portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
S			}
S			portEXIT_CRITICAL();
S		}
S	}
S
N#endif /* #if configUSE_TICKLESS_IDLE */
N
N/*-----------------------------------------------------------*/
N
N/*
N * Setup the SysTick timer to generate the tick interrupts at the required
N * frequency.
N */
N#if configOVERRIDE_DEFAULT_TICK_CONFIGURATION == 0
X#if 0 == 0
N
N	void vPortSetupTimerInterrupt( void )
N	{
N		/* Calculate the constants required to configure the tick interrupt. */
N		#if configUSE_TICKLESS_IDLE == 1
X		#if 0 == 1
S		{
S			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
S			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
S			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
S		}
N		#endif /* configUSE_TICKLESS_IDLE */
N
N		/* Configure SysTick to interrupt at the requested rate. */
N		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
X		( * ( ( volatile unsigned long * ) 0xe000e014 ) ) = ( ( ( unsigned long ) 32000000 ) / ( ( portTickType ) 500 ) ) - 1UL;;
N		portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
X		( * ( ( volatile unsigned long * ) 0xe000e010 ) ) = ( 1UL << 2UL ) | ( 1UL << 1UL ) | ( 1UL << 0UL );
N	}
N
N#endif /* configOVERRIDE_DEFAULT_TICK_CONFIGURATION */
N/*-----------------------------------------------------------*/
N
N__asm unsigned long ulPortSetInterruptMask( void )
N{
N	PRESERVE8
N
N	mrs r0, basepri
N	mov r1, #configMAX_SYSCALL_INTERRUPT_PRIORITY
X	mov r1, #0x20
N	msr basepri, r1
N	bx r14
N}
N/*-----------------------------------------------------------*/
N
N__asm void vPortClearInterruptMask( unsigned long ulNewMask )
N{
N	PRESERVE8
N
N	msr basepri, r0
N	bx r14
N}
N/*-----------------------------------------------------------*/
N
N__asm unsigned long vPortGetIPSR( void )
N{
N	PRESERVE8
N	
N	mrs r0, ipsr
N	bx r14
N}
N/*-----------------------------------------------------------*/
N
N#if( configASSERT_DEFINED == 1 )
X#if( 0 == 1 )
S
S	void vPortValidateInterruptPriority( void )
S	{
S	unsigned long ulCurrentInterrupt;
S	unsigned char ucCurrentPriority;
S
S		/* Obtain the number of the currently executing interrupt. */
S		ulCurrentInterrupt = vPortGetIPSR();
S
S		/* Is the interrupt number a user defined interrupt? */
S		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
S		{
S			/* Look up the interrupt's priority. */
S			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
S
S			/* The following assertion will fail if a service routine (ISR) for
S			an interrupt that has been assigned a priority above
S			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
S			function.  ISR safe FreeRTOS API functions must *only* be called
S			from interrupts that have been assigned a priority at or below
S			configMAX_SYSCALL_INTERRUPT_PRIORITY.
S
S			Numerically low interrupt priority numbers represent logically high
S			interrupt priorities, therefore the priority of the interrupt must
S			be set to a value equal to or numerically *higher* than
S			configMAX_SYSCALL_INTERRUPT_PRIORITY.
S
S			Interrupts that	use the FreeRTOS API must not be left at their
S			default priority of	zero as that is the highest possible priority,
S			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
S			and	therefore also guaranteed to be invalid.
S
S			FreeRTOS maintains separate thread and ISR API functions to ensure
S			interrupt entry is as fast and simple as possible.
S
S			The following links provide detailed information:
S			http://www.freertos.org/RTOS-Cortex-M3-M4.html
S			http://www.freertos.org/FAQHelp.html */
S			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
S		}
S
S		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
S		that define each interrupt's priority to be split between bits that
S		define the interrupt's pre-emption priority bits and bits that define
S		the interrupt's sub-priority.  For simplicity all bits must be defined
S		to be pre-emption priority bits.  The following assertion will fail if
S		this is not the case (if some bits represent a sub-priority).
S
S		If the application only uses CMSIS libraries for interrupt
S		configuration then the correct setting can be achieved on all Cortex-M
S		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
S		scheduler.  Note however that some vendor specific peripheral libraries
S		assume a non-zero priority group setting, in which cases using a value
S		of zero will result in unpredicable behaviour. */
S		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
S	}
S
N#endif /* configASSERT_DEFINED */
N
N
